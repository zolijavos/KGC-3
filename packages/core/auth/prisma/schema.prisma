// KGC ERP v3.0 - Auth Module Prisma Schema
// Story 1.1: JWT Login Endpoint
// ADR-001: Multi-tenancy with RLS
// ADR-032: RBAC Architecture (8 roles)

generator client {
  provider = "prisma-client-js"
  output   = "../node_modules/.prisma/client"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ============================================
// ENUMS
// ============================================

/// User roles per ADR-032 RBAC Architecture
enum Role {
  OPERATOR      // Pultos / Értékesítő (Level 1)
  TECHNIKUS     // Szerviz technikus (Level 2)
  BOLTVEZETO    // Boltvezető (Level 3)
  ACCOUNTANT    // Könyvelő (Level 3)
  PARTNER_OWNER // Franchise Partner Tulajdonos (Level 4)
  CENTRAL_ADMIN // Központi Admin (Level 5)
  DEVOPS_ADMIN  // DevOps / IT Admin (Level 6)
  SUPER_ADMIN   // Rendszergazda (Level 8)
}

/// User account status
enum UserStatus {
  ACTIVE
  INACTIVE
  LOCKED
  PENDING_VERIFICATION
}

// ============================================
// MODELS
// ============================================

/// User entity for authentication
/// AC1: User with email/password for JWT login
/// AC2: Password stored as bcrypt hash
/// Story 1.4: PIN hash for kiosk mode
/// Story 1.5: Password reset tokens relation
/// Story 2.1: Soft delete support (deletedAt, deletedEmail)
model User {
  id           String     @id @default(uuid()) @db.Uuid
  email        String     @unique @db.VarChar(255)
  passwordHash String     @map("password_hash") @db.VarChar(255)
  name         String     @db.VarChar(255)
  role         Role       @default(OPERATOR)
  tenantId     String     @map("tenant_id") @db.Uuid
  locationId   String?    @map("location_id") @db.Uuid // Story 1.4: Location for PIN lookup
  status       UserStatus @default(ACTIVE)
  pinHash      String?    @map("pin_hash") @db.VarChar(255) // Story 1.4: bcrypt PIN hash

  // Story 2.1: Soft delete support
  deletedAt    DateTime?  @map("deleted_at") @db.Timestamptz
  deletedEmail String?    @map("deleted_email") @db.VarChar(255) // Original email before _deleted_TIMESTAMP suffix

  // Story 2.6: User Profile fields
  phone        String?    @db.VarChar(20)
  avatarUrl    String?    @map("avatar_url") @db.VarChar(500)

  // Timestamps
  createdAt DateTime @default(now()) @map("created_at") @db.Timestamptz
  updatedAt DateTime @updatedAt @map("updated_at") @db.Timestamptz

  // Relations
  refreshTokens       RefreshToken[]
  passwordResetTokens PasswordResetToken[] // Story 1.5

  // Indexes for performance
  @@index([email])
  @@index([tenantId])
  @@index([role])
  @@index([status]) // Story 2.1: For filtering by status
  @@index([tenantId, locationId]) // Story 1.4: For PIN lookup
  @@map("users")
}

/// RefreshToken entity for token management
/// AC1: Refresh token with 7d TTL
model RefreshToken {
  id         String   @id @default(uuid()) @db.Uuid
  token      String   @unique @db.VarChar(500)
  userId     String   @map("user_id") @db.Uuid
  expiresAt  DateTime @map("expires_at") @db.Timestamptz
  deviceInfo String?  @map("device_info") @db.VarChar(500)

  // Security: Track token usage
  isRevoked Boolean @default(false) @map("is_revoked")
  revokedAt DateTime? @map("revoked_at") @db.Timestamptz

  // Timestamps
  createdAt DateTime @default(now()) @map("created_at") @db.Timestamptz

  // Relations
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Indexes for performance
  @@index([token])
  @@index([userId])
  @@index([expiresAt])
  @@map("refresh_tokens")
}

/// Login attempt tracking for rate limiting and security
/// AC3, AC4: Track failed attempts for rate limiting
model LoginAttempt {
  id        String   @id @default(uuid()) @db.Uuid
  email     String   @db.VarChar(255)
  ipAddress String   @map("ip_address") @db.VarChar(45)
  success   Boolean  @default(false)
  userAgent String?  @map("user_agent") @db.VarChar(500)

  createdAt DateTime @default(now()) @map("created_at") @db.Timestamptz

  @@index([email, ipAddress, createdAt])
  @@index([ipAddress, createdAt])
  @@map("login_attempts")
}

/// Password reset token for forgot password flow
/// Story 1.5: Password Reset Flow
/// AC1: Reset token with 1h TTL
/// AC3: One-time use token
model PasswordResetToken {
  id        String    @id @default(uuid()) @db.Uuid
  tokenHash String    @unique @map("token_hash") @db.VarChar(128) // SHA-256 hash of token
  userId    String    @map("user_id") @db.Uuid
  expiresAt DateTime  @map("expires_at") @db.Timestamptz
  isUsed    Boolean   @default(false) @map("is_used")
  usedAt    DateTime? @map("used_at") @db.Timestamptz

  createdAt DateTime @default(now()) @map("created_at") @db.Timestamptz

  // Relations
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([tokenHash])
  @@index([userId])
  @@index([expiresAt])
  @@map("password_reset_tokens")
}

/// Trusted device for kiosk mode PIN login
/// Story 1.4: PIN Kód Belépés (Kiosk Mód)
/// AC2: Only registered devices can use PIN
model TrustedDevice {
  id           String   @id @default(uuid()) @db.Uuid
  tenantId     String   @map("tenant_id") @db.Uuid
  locationId   String   @map("location_id") @db.Uuid
  deviceName   String   @map("device_name") @db.VarChar(255)
  status       String   @default("ACTIVE") @db.VarChar(20) // ACTIVE, SUSPENDED, REVOKED
  lastUsedAt   DateTime? @map("last_used_at") @db.Timestamptz
  registeredAt DateTime @default(now()) @map("registered_at") @db.Timestamptz

  @@index([tenantId, locationId])
  @@index([status])
  @@map("trusted_devices")
}

/// PIN attempt tracking for kiosk lockout
/// Story 1.4: PIN Kód Belépés (Kiosk Mód)
/// AC3: 3 failed attempts = lockout
model PinAttempt {
  id            String    @id @default(uuid()) @db.Uuid
  userId        String    @map("user_id") @db.Uuid
  deviceId      String    @map("device_id") @db.Uuid
  attemptCount  Int       @default(0) @map("attempt_count")
  lockedUntil   DateTime? @map("locked_until") @db.Timestamptz
  lastAttemptAt DateTime  @default(now()) @map("last_attempt_at") @db.Timestamptz
  createdAt     DateTime  @default(now()) @map("created_at") @db.Timestamptz
  updatedAt     DateTime  @updatedAt @map("updated_at") @db.Timestamptz

  @@unique([userId, deviceId])
  @@index([lockedUntil])
  @@map("pin_attempts")
}
